{
"Template for vue components unit tests": {
  "prefix": "test-vue",
  "body": [
    "import { shallowMount, createLocalVue } from '@vue/test-utils';",
    "import Vuex from 'vuex';",
    "import Component from '';",
    "import STORE_MOCK from '';",
    "",
    "const localVue = createLocalVue();",
    "localVue.use(Vuex);",
    "",
    "describe('Given the <ComponentName>', () => {",
    "  let wrapper;",
    "",
    "  const store = new Vuex.Store({",
    "    modules: {",
    "      moduleName: STORE_MOCK,",
    "    },",
    "  });",
    "",
    "  const factory = propsData => shallowMount(Component, {",
    "    propsData,",
    "    store,",
    "    localVue,",
    "  });",
    "",
    "  beforeAll(() => {",
    "    wrapper = factory();",
    "  });",
    "",
    "  afterAll(() => {",
    "    wrapper.destroy();",
    "  });",
    "",
    "  beforeEach(() => {",
    "    jest.clearAllMocks();",
    "    expect.hasAssertions();",
    "  });",
    "",
    "  it('Then component name should be <name>', () => {",
    "    expect(Component.name).toBe('name');",
    "  });",
    "",
    "  describe('And given the component lifecycle', () => {",
    "    describe('created', () => {",
    "      // TODO: write tests for all code inside the created hook of your component",
    "    });",
    "",
    "    describe('mounted', () => {",
    "      // TODO: write tests for all code inside the mounted hook of your component",
    "    });",
    "",
    "    describe('beforeDestroy', () => {",
    "      // TODO: write tests for all code inside the beforeDestroy hook of your component",
    "    });",
    "  });",
    "",
    "  describe('When user interact with component', () => {",
    "    /*",
    "      Each user interaction that results in a side effect should be tested",
    "      Examples: a button click which call a method or a text type on input that filter a list",
    "",
    "      describe('when the button \"confirmation\" is clicked once', () => {",
    "        beforeEach(() => {",
    "          // click the button",
    "        })",
    "",
    "        it('then method-name should be called once')",
    "      })",
    "    */",
    "  })",
    "",
    "  describe('And given the sub-components', () => {",
    "    /*",
    "      Each sub-component should be tested.",
    "      if exists some constraint to show the component (like a v-if), write a describe for the specific scenario.",
    "      Example of a component wich is visible all the time:",
    "",
    "      it('Then sub-component-name should be visible', () => {",
    "        expect(wrapper.findComponent({ name: 'sub-component-name' }).isVisible()).toBe(true);",
    "      })",
    "",
    "      Example of a component wich have a v-if:",
    "      describe('sub-component-name', () => {",
    "        describe('If the condition to render the sub-component is true', () => {",
    "            beforeEach(() => {",
    "            // setup the condition",
    "            })",
    "",
    "            it('component should be visible')",
    "        })",
    "",
    "        describe('If the condition to render the sub-component is false', () => {",
    "            beforeEach(() => {",
    "            // setup the condition",
    "            })",
    "",
    "            it('component should NOT be visible')",
    "        })",
    "      })",
    "    */",
    "  });",
    "",
    "  describe('And given the computed properties', () => {",
    "    /*",
    "      Each computed property (including those from mapGetters, if exists) must have a describe.",
    "      inside of each describe, write tests for specific scenarios of that computed. Example:",
    "",
    "      describe('computedName', () => {",
    "        it('scenario', () => {",
    "          // only one expect inside for each it",
    "          expect('....')",
    "        })",
    "      })",
    "    */",
    "  });",
    "",
    "  describe('And given the methods', () => {",
    "    /*",
    "      Each method (including those from mapActions and mapMutations, if exists) must have a describe.",
    "      inside of each describe, write tests for specific scenarios of that method. Example:",
    "",
    "      describe('methodName', () => {",
    "        beforeEach(() => {",
    "          // call the method here",
    "          // wrapper.vm.methodName()",
    "        })",
    "",
    "        it('scenario', () => {",
    "          // only one expect inside for each it",
    "          expect('....')",
    "        })",
    "      })",
    "    */",
    "  });",
    "",
    "  describe('When a watched property change', () => {",
    "    /*",
    "      Each watched value must have a describe.",
    "      inside of each describe, write tests for specific scenarios of that watched value. Example:",
    "",
    "      describe('watchedValueName', () => {",
    "        beforeEach(() => {",
    "          // do something here to change your watched property",
    "        });",
    "",
    "        it('scenario', () => {",
    "          // only one expect inside for each it",
    "          expect('....')",
    "        })",
    "      })",
    "    */",
    "  });",
    "});",
    ""
  ],
  "description": "Template for vue components unit tests"
  }
}